#!/usr/bin/env python3
"""
Image Duplicate Viewer GUI
A graphical interface to view images and their duplicates based on the results
generated by the notebook's duplicate detection algorithm.
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from PIL import Image, ImageTk
import csv
import os
from pathlib import Path
from collections import defaultdict
import json


class ImageDuplicateViewer:
    def __init__(self, root):
        self.root = root
        self.root.title("Image Duplicate Viewer")
        self.root.geometry("1200x800")
        
        # Data storage
        self.duplicate_groups = []
        self.current_group_index = 0
        self.images_dir = Path("images")
        self.results_dir = Path("results")
        
        # Image display settings
        self.thumbnail_size = (200, 200)
        self.large_image_size = (400, 400)
        
        # Initialize GUI
        self.setup_gui()
        self.load_data()
        
    def setup_gui(self):
        """Create the main GUI layout"""
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Control panel (left side)
        self.setup_control_panel(main_frame)
        
        # Image display area (right side)
        self.setup_image_display(main_frame)
        
        # Status bar
        self.status_var = tk.StringVar()
        self.status_var.set("Ready - Load duplicate data to begin")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN)
        status_bar.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
        
    def setup_control_panel(self, parent):
        """Create the control panel with navigation and options"""
        control_frame = ttk.LabelFrame(parent, text="Controls", padding="10")
        control_frame.grid(row=0, column=0, rowspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), padx=(0, 10))
        
        # Load data button
        ttk.Button(control_frame, text="Load Duplicate Data", 
                  command=self.load_data).grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Group navigation
        nav_frame = ttk.LabelFrame(control_frame, text="Navigate Groups", padding="5")
        nav_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        nav_frame.columnconfigure(1, weight=1)
        
        ttk.Button(nav_frame, text="◀ Previous", command=self.prev_group).grid(row=0, column=0, padx=(0, 5))
        ttk.Button(nav_frame, text="Next ▶", command=self.next_group).grid(row=0, column=2, padx=(5, 0))
        
        self.group_var = tk.StringVar()
        self.group_label = ttk.Label(nav_frame, textvariable=self.group_var)
        self.group_label.grid(row=0, column=1, padx=5)
        
        # Group info
        info_frame = ttk.LabelFrame(control_frame, text="Group Information", padding="5")
        info_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.info_text = tk.Text(info_frame, height=8, width=30, wrap=tk.WORD)
        info_scrollbar = ttk.Scrollbar(info_frame, orient=tk.VERTICAL, command=self.info_text.yview)
        self.info_text.configure(yscrollcommand=info_scrollbar.set)
        
        self.info_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        info_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        info_frame.columnconfigure(0, weight=1)
        info_frame.rowconfigure(0, weight=1)
        
        # Options
        options_frame = ttk.LabelFrame(control_frame, text="Display Options", padding="5")
        options_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.show_filenames = tk.BooleanVar(value=True)
        ttk.Checkbutton(options_frame, text="Show filenames", 
                       variable=self.show_filenames, command=self.update_display).grid(row=0, column=0, sticky=tk.W)
        
        self.show_similarity = tk.BooleanVar(value=True)
        ttk.Checkbutton(options_frame, text="Show similarity scores", 
                       variable=self.show_similarity, command=self.update_display).grid(row=1, column=0, sticky=tk.W)
        
        # Export options
        export_frame = ttk.LabelFrame(control_frame, text="Export", padding="5")
        export_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E))
        
        ttk.Button(export_frame, text="Export Current Group", 
                  command=self.export_current_group).grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        ttk.Button(export_frame, text="Export All Groups", 
                  command=self.export_all_groups).grid(row=1, column=0, sticky=(tk.W, tk.E))
        
    def setup_image_display(self, parent):
        """Create the image display area with scrolling"""
        display_frame = ttk.LabelFrame(parent, text="Duplicate Images", padding="10")
        display_frame.grid(row=0, column=1, rowspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
        display_frame.columnconfigure(0, weight=1)
        display_frame.rowconfigure(0, weight=1)
        
        # Create canvas with scrollbars for image display
        self.canvas = tk.Canvas(display_frame, bg='white')
        v_scrollbar = ttk.Scrollbar(display_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        h_scrollbar = ttk.Scrollbar(display_frame, orient=tk.HORIZONTAL, command=self.canvas.xview)
        
        self.canvas.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        
        self.canvas.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        v_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        h_scrollbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        # Create frame inside canvas for images
        self.image_frame = ttk.Frame(self.canvas)
        self.canvas.create_window((0, 0), window=self.image_frame, anchor="nw")
        
        # Bind canvas resize
        self.canvas.bind('<Configure>', self.on_canvas_configure)
        self.image_frame.bind('<Configure>', self.on_frame_configure)
        
        # Bind mousewheel to canvas
        self.canvas.bind("<MouseWheel>", self.on_mousewheel)
        
    def on_canvas_configure(self, event):
        """Handle canvas resize"""
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        
    def on_frame_configure(self, event):
        """Handle frame resize"""
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        
    def on_mousewheel(self, event):
        """Handle mouse wheel scrolling"""
        self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
        
    def load_data(self):
        """Load duplicate detection results from CSV files"""
        try:
            # Try to load duplicate_groups.csv first
            groups_file = self.results_dir / "duplicate_groups.csv"
            pairs_file = self.results_dir / "verified_pairs.csv"
            detailed_file = self.results_dir / "detailed_duplicate_pairs.csv"
            
            if groups_file.exists():
                self.load_grouped_data(groups_file, detailed_file)
            elif pairs_file.exists():
                self.load_pairs_data(pairs_file)
            else:
                # Let user select files
                self.browse_for_data_files()
                
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load data: {str(e)}")
            
    def load_grouped_data(self, groups_file, detailed_file=None):
        """Load data from duplicate_groups.csv"""
        self.duplicate_groups = []
        similarity_data = {}
        
        # Load similarity data if available
        if detailed_file and detailed_file.exists():
            with open(detailed_file, 'r', newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    key = tuple(sorted([row['image1'], row['image2']]))
                    similarity_data[key] = {
                        'hamming_distance': int(row['hamming_distance']),
                        'group_id': row['group_id']
                    }
        
        # Load groups
        with open(groups_file, 'r', newline='', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                images = [img.strip() for img in row['images'].split(';')]
                group_data = {
                    'id': row['group_id'],
                    'size': int(row['group_size']),
                    'images': images,
                    'similarities': {}
                }
                
                # Add similarity data for this group
                for i, img1 in enumerate(images):
                    for img2 in images[i+1:]:
                        key = tuple(sorted([img1, img2]))
                        if key in similarity_data:
                            group_data['similarities'][key] = similarity_data[key]
                
                self.duplicate_groups.append(group_data)
        
        self.current_group_index = 0
        self.update_display()
        self.status_var.set(f"Loaded {len(self.duplicate_groups)} duplicate groups")
        
    def load_pairs_data(self, pairs_file):
        """Load data from verified_pairs.csv and group them"""
        pairs = []
        with open(pairs_file, 'r', newline='', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                pairs.append((row['image1'], row['image2'], int(row['hamming_distance'])))
        
        # Group pairs using Union-Find
        groups = self.group_pairs(pairs)
        
        self.duplicate_groups = []
        for i, group in enumerate(groups, 1):
            group_data = {
                'id': f'Group_{i}',
                'size': len(group),
                'images': list(group),
                'similarities': {}
            }
            
            # Add similarity data
            for img1 in group:
                for img2 in group:
                    if img1 < img2:  # Avoid duplicates
                        for p1, p2, dist in pairs:
                            if (p1 == img1 and p2 == img2) or (p1 == img2 and p2 == img1):
                                key = tuple(sorted([img1, img2]))
                                group_data['similarities'][key] = {'hamming_distance': dist}
                                break
            
            self.duplicate_groups.append(group_data)
        
        self.current_group_index = 0
        self.update_display()
        self.status_var.set(f"Loaded {len(self.duplicate_groups)} duplicate groups from pairs")
        
    def group_pairs(self, pairs):
        """Group pairs using Union-Find algorithm"""
        # Create mapping
        all_images = set()
        for img1, img2, _ in pairs:
            all_images.add(img1)
            all_images.add(img2)
        
        image_to_idx = {img: idx for idx, img in enumerate(sorted(all_images))}
        idx_to_image = {idx: img for img, idx in image_to_idx.items()}
        
        # Union-Find
        parent = list(range(len(all_images)))
        
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            root_x, root_y = find(x), find(y)
            if root_x != root_y:
                parent[root_y] = root_x
        
        # Union pairs
        for img1, img2, _ in pairs:
            idx1, idx2 = image_to_idx[img1], image_to_idx[img2]
            union(idx1, idx2)
        
        # Group by root
        groups = defaultdict(set)
        for idx in range(len(all_images)):
            root = find(idx)
            groups[root].add(idx_to_image[idx])
        
        return [group for group in groups.values() if len(group) > 1]
        
    def browse_for_data_files(self):
        """Let user browse for data files"""
        file_path = filedialog.askopenfilename(
            title="Select duplicate data file",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialdir=str(Path.cwd())
        )
        
        if file_path:
            file_path = Path(file_path)
            if "group" in file_path.name.lower():
                self.load_grouped_data(file_path)
            else:
                self.load_pairs_data(file_path)
                
    def prev_group(self):
        """Navigate to previous group"""
        if self.duplicate_groups and self.current_group_index > 0:
            self.current_group_index -= 1
            self.update_display()
            
    def next_group(self):
        """Navigate to next group"""
        if self.duplicate_groups and self.current_group_index < len(self.duplicate_groups) - 1:
            self.current_group_index += 1
            self.update_display()
            
    def update_display(self):
        """Update the image display and group information"""
        # Clear existing images
        for widget in self.image_frame.winfo_children():
            widget.destroy()
            
        if not self.duplicate_groups:
            self.group_var.set("No data loaded")
            self.info_text.delete(1.0, tk.END)
            return
            
        # Update group navigation info
        current_group = self.duplicate_groups[self.current_group_index]
        self.group_var.set(f"Group {self.current_group_index + 1} of {len(self.duplicate_groups)}")
        
        # Update group information
        self.update_group_info(current_group)
        
        # Display images
        self.display_group_images(current_group)
        
    def update_group_info(self, group):
        """Update the group information text"""
        self.info_text.delete(1.0, tk.END)
        
        info = f"Group ID: {group['id']}\n"
        info += f"Number of duplicates: {group['size']}\n\n"
        
        info += "Images in this group:\n"
        for i, img in enumerate(group['images'], 1):
            info += f"{i}. {img}\n"
            
        if group['similarities']:
            info += "\nSimilarity scores:\n"
            for (img1, img2), sim_data in group['similarities'].items():
                hamming = sim_data.get('hamming_distance', 'N/A')
                info += f"• {img1} ↔ {img2}: Hamming distance = {hamming}\n"
                
        self.info_text.insert(1.0, info)
        
    def display_group_images(self, group):
        """Display all images in the current group"""
        images_per_row = 3
        current_row = 0
        current_col = 0
        
        for i, image_name in enumerate(group['images']):
            self.display_single_image(image_name, current_row, current_col, i + 1)
            
            current_col += 1
            if current_col >= images_per_row:
                current_col = 0
                current_row += 1
                
        # Update scroll region
        self.image_frame.update_idletasks()
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        
    def display_single_image(self, image_name, row, col, number):
        """Display a single image with optional filename and number"""
        image_path = self.images_dir / image_name
        
        # Create frame for this image
        img_frame = ttk.Frame(self.image_frame, relief=tk.RAISED, borderwidth=2, padding=10)
        img_frame.grid(row=row, column=col, padx=10, pady=10, sticky=(tk.N, tk.S))
        
        try:
            # Load and resize image
            pil_image = Image.open(image_path)
            pil_image.thumbnail(self.thumbnail_size, Image.Resampling.LANCZOS)
            
            # Convert to PhotoImage
            photo = ImageTk.PhotoImage(pil_image)
            
            # Create label for image
            img_label = ttk.Label(img_frame, image=photo)
            img_label.image = photo  # Keep a reference
            img_label.grid(row=0, column=0, pady=(0, 5))
            
            # Add click handler for enlarging image
            img_label.bind("<Button-1>", lambda e, path=image_path: self.show_large_image(path))
            
            # Add filename if option is enabled
            if self.show_filenames.get():
                filename_label = ttk.Label(img_frame, text=f"{number}. {image_name}", 
                                         font=('Arial', 8), wraplength=200)
                filename_label.grid(row=1, column=0)
                
        except Exception as e:
            # Show error placeholder
            error_label = ttk.Label(img_frame, text=f"Error loading:\n{image_name}\n({str(e)})", 
                                  foreground='red', wraplength=200)
            error_label.grid(row=0, column=0)
            
    def show_large_image(self, image_path):
        """Show enlarged version of image in a new window"""
        try:
            # Create new window
            img_window = tk.Toplevel(self.root)
            img_window.title(f"Large View - {image_path.name}")
            img_window.geometry("500x500")
            
            # Load and resize image
            pil_image = Image.open(image_path)
            pil_image.thumbnail(self.large_image_size, Image.Resampling.LANCZOS)
            
            # Convert to PhotoImage
            photo = ImageTk.PhotoImage(pil_image)
            
            # Create label
            img_label = ttk.Label(img_window, image=photo)
            img_label.image = photo  # Keep reference
            img_label.pack(expand=True)
            
            # Add filename
            filename_label = ttk.Label(img_window, text=image_path.name, font=('Arial', 12, 'bold'))
            filename_label.pack(pady=10)
            
        except Exception as e:
            messagebox.showerror("Error", f"Could not display image: {str(e)}")
            
    def export_current_group(self):
        """Export current group information"""
        if not self.duplicate_groups:
            messagebox.showwarning("Warning", "No data to export")
            return
            
        current_group = self.duplicate_groups[self.current_group_index]
        
        file_path = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("Text files", "*.txt")],
            title="Save group data"
        )
        
        if file_path:
            try:
                with open(file_path, 'w') as f:
                    json.dump(current_group, f, indent=2)
                messagebox.showinfo("Success", f"Group data exported to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export: {str(e)}")
                
    def export_all_groups(self):
        """Export all groups information"""
        if not self.duplicate_groups:
            messagebox.showwarning("Warning", "No data to export")
            return
            
        file_path = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json")],
            title="Save all groups data"
        )
        
        if file_path:
            try:
                with open(file_path, 'w') as f:
                    json.dump(self.duplicate_groups, f, indent=2)
                messagebox.showinfo("Success", f"All groups exported to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export: {str(e)}")


def main():
    """Main function to run the application"""
    root = tk.Tk()
    app = ImageDuplicateViewer(root)
    
    try:
        root.mainloop()
    except KeyboardInterrupt:
        print("\nApplication closed by user")


if __name__ == "__main__":
    main()